/*
** src/puzzles/aoc2024/day22.rs
*/

use super::Solution;
use crate::utils;

use std::collections::{HashMap, HashSet};

fn next_secret(mut number: u64) -> u64 {
    number = (number ^ (number << 6)) & 0xFFFFFF;
    number = (number ^ (number >> 5)) & 0xFFFFFF;
    (number ^ (number << 11)) & 0xFFFFFF
}

fn generate_secret_numbers(mut number: u64, count: usize) -> Vec<u64> {
    let mut output = Vec::with_capacity(count);
    output.push(number);
    for _ in 0..count {
        number = next_secret(number);
        output.push(number);
    }
    output
}

fn price_changes(prices: &[u64]) -> Vec<i64> {
    prices
        .iter()
        .enumerate()
        .skip(1)
        .map(|(i, &p)| p as i64 - prices[i - 1] as i64)
        .collect()
}

fn generate_sequences<'a>(
    all_prices: &[Vec<u64>],
    all_changes: &'a [Vec<i64>],
) -> Vec<HashMap<&'a [i64], u64>> {
    let mut output = Vec::with_capacity(all_prices.len());
    for (prices, changes) in all_prices.iter().zip(all_changes.iter()) {
        let mut map = HashMap::new();
        for i in 0..=(changes.len() - 4) {
            let sequence = &changes[i..(i + 4)];
            let cost = prices[i + 4];
            map.entry(sequence).or_insert(cost);
        }
        output.push(map);
    }
    output
}

fn banana_count(sequence_map: &[HashMap<&[i64], u64>], sequence: &[i64]) -> u64 {
    let mut count = 0;
    for map in sequence_map.iter() {
        if let Some(price) = map.get(sequence) {
            count += price;
        }
    }
    count
}

fn find_best_sequence(all_secrets: &[Vec<u64>]) -> u64 {
    let all_prices = all_secrets
        .iter()
        .map(|sequence| {
            sequence
                .iter()
                .map(|number| number % 10)
                .collect::<Vec<_>>()
        })
        .collect::<Vec<_>>();
    let all_changes = all_prices
        .iter()
        .map(|prices| price_changes(prices))
        .collect::<Vec<_>>();

    let sequence_map = generate_sequences(&all_prices, &all_changes);
    let sequences = sequence_map
        .iter()
        .flat_map(|map| map.keys())
        .collect::<HashSet<_>>();

    let mut best = 0;
    for sequence in sequences {
        let count = banana_count(&sequence_map, sequence);
        if count > best {
            best = count;
        }
    }
    best
}

pub fn solve(input: String) -> Solution {
    let mut solution = Solution::new();
    // On the Market, the buyers seem to use random prices, but their prices are actually only
    // pseudorandom! If you know the secret of how they pick their prices, you can wait for the
    // perfect time to sell.
    let secret_numbers = utils::split_and_parse(&input).collect::<Vec<u64>>();

    // Part A: For each buyer, simulate the creation of 2000 new secret numbers. What is the sum of
    // the 2000th secret number generated by each buyer?
    let all_secrets = secret_numbers
        .into_iter()
        .map(|number| generate_secret_numbers(number, 2000))
        .collect::<Vec<_>>();
    let sum = all_secrets
        .iter()
        .map(|sequence| sequence.last().unwrap())
        .sum::<u64>();
    solution.set_part_a(sum);

    // Part B: Figure out the best sequence to tell the monkey so that by looking for that same
    // sequence of changes in every buyer's future prices, you get the most bananas in total. What
    // is the most bananas you can get?
    let bananas = find_best_sequence(&all_secrets);
    solution.set_part_b(bananas);

    solution
}
